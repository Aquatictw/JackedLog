---
phase: 10-server-foundation
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - server/lib/services/sqlite_validator.dart
  - server/lib/services/backup_service.dart
  - server/lib/api/backup_api.dart
  - server/bin/server.dart
autonomous: true

must_haves:
  truths:
    - "POST /api/backup accepts a file upload and stores it as jackedlog_backup_YYYY-MM-DD.db"
    - "POST /api/backup rejects invalid SQLite files with 400 error"
    - "GET /api/backups returns JSON array of backups with date, size, and DB version"
    - "GET /api/backup/<filename> returns the backup file for download"
    - "DELETE /api/backup/<filename> removes the backup and returns 200"
    - "Retention cleanup runs after each upload and preserves recent + weekly + monthly backups"
  artifacts:
    - path: "server/lib/services/sqlite_validator.dart"
      provides: "SQLite integrity check and DB version extraction"
      contains: "PRAGMA quick_check"
    - path: "server/lib/services/backup_service.dart"
      provides: "Backup storage, listing, deletion, retention cleanup"
      contains: "cleanupOldBackups"
    - path: "server/lib/api/backup_api.dart"
      provides: "POST/GET/DELETE backup endpoint handlers"
      exports: ["uploadBackupHandler", "listBackupsHandler", "downloadBackupHandler", "deleteBackupHandler"]
  key_links:
    - from: "server/lib/api/backup_api.dart"
      to: "server/lib/services/backup_service.dart"
      via: "function calls for store, list, delete, cleanup"
      pattern: "backupService"
    - from: "server/lib/services/backup_service.dart"
      to: "server/lib/services/sqlite_validator.dart"
      via: "validation on upload"
      pattern: "validateBackup"
    - from: "server/bin/server.dart"
      to: "server/lib/api/backup_api.dart"
      via: "router.post/get/delete routes"
      pattern: "backup"
---

<objective>
Implement the SQLite backup validation service, backup storage/listing/retention service, and all backup API endpoints (upload, list, download, delete). Wire backup routes into the server entry point.

Purpose: This is the core server functionality — receiving and managing backup files is the primary reason the server exists.
Output: Working backup CRUD API with SQLite integrity validation and tiered retention cleanup.
</objective>

<execution_context>
@/home/aquatic/.claude/get-shit-done/workflows/execute-plan.md
@/home/aquatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-server-foundation/10-CONTEXT.md
@.planning/phases/10-server-foundation/10-RESEARCH.md
@.planning/phases/10-server-foundation/10-01-SUMMARY.md
@lib/backup/auto_backup_service.dart (reference for retention policy logic)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite validator and backup service</name>
  <files>
    server/lib/services/sqlite_validator.dart
    server/lib/services/backup_service.dart
  </files>
  <action>
    **server/lib/services/sqlite_validator.dart:**
    - Class `ValidationResult` with fields: `isValid` (bool), `dbVersion` (int?), `error` (String?)
    - Function `ValidationResult validateBackup(String filePath)`:
      - Open file with `sqlite3.open(filePath, mode: OpenMode.readOnly)`
      - Run `PRAGMA quick_check` — if result is not 'ok', return invalid with error message
      - Run `PRAGMA user_version` — extract int version
      - Always dispose db in finally block
      - Catch all exceptions and return invalid with error message

    **server/lib/services/backup_service.dart:**
    - Class `BackupInfo` with fields: `filename` (String), `date` (DateTime), `sizeBytes` (int), `dbVersion` (int?), `isValid` (bool)
    - Class `BackupService` with constructor taking `dataDir` (String):

    Methods:
    1. `Future<BackupInfo> storeBackup(Stream<List<int>> fileStream)`:
       - Stream bytes to temp file `$dataDir/.upload_temp`
       - Validate with `validateBackup(tempFile.path)` — if invalid, delete temp file and throw
       - Generate filename: `jackedlog_backup_YYYY-MM-DD.db` using today's date
       - Rename temp to `$dataDir/$filename` (overwrites same-day backup by design)
       - Run `cleanupOldBackups()`
       - Return BackupInfo

    2. `List<BackupInfo> listBackups()`:
       - List all `.db` files in dataDir matching `jackedlog_backup_*.db` pattern
       - For each file: parse date from filename, get file size from stat, read dbVersion with validateBackup
       - Sort by date descending (newest first)
       - Return list

    3. `File? getBackup(String filename)`:
       - Sanitize filename (reject if contains path separators or doesn't match expected pattern)
       - Return File if exists, null otherwise

    4. `bool deleteBackup(String filename)`:
       - Sanitize filename (same validation as getBackup)
       - Delete file if exists, return true
       - Return false if file doesn't exist

    5. `int totalStorageBytes()`:
       - Sum sizes of all .db files in dataDir

    6. `void cleanupOldBackups()`:
       - Port the GFS retention logic from `lib/backup/auto_backup_service.dart` (lines 148-258)
       - Keep all backups from last 7 days
       - Keep weekly backups (closest to Sunday) for 30 days
       - Keep monthly backups (closest to month-end) beyond that
       - Always keep the most recent backup regardless
       - Use synchronous file operations (server context, not Flutter)
       - Include `_parseDateFromFilename` and `_findClosestBackup` helper methods

    **Important:** Sanitize all filenames — reject any containing `/`, `\`, `..`, or not matching `jackedlog_backup_\d{4}-\d{2}-\d{2}\.db` regex to prevent path traversal.
  </action>
  <verify>
    `rg "PRAGMA quick_check" server/lib/services/sqlite_validator.dart` confirms integrity check. `rg "cleanupOldBackups" server/lib/services/backup_service.dart` confirms retention. `rg "jackedlog_backup_" server/lib/services/backup_service.dart` confirms naming convention.
  </verify>
  <done>
    SQLite validator runs PRAGMA quick_check and extracts user_version. Backup service stores, lists, downloads, deletes, and auto-cleans backups with GFS retention policy matching the app's existing logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backup API endpoints and wire to router</name>
  <files>
    server/lib/api/backup_api.dart
    server/bin/server.dart
  </files>
  <action>
    **server/lib/api/backup_api.dart:**
    - Create endpoint handler functions that use a `BackupService` instance:

    1. `Future<Response> uploadBackupHandler(Request request, BackupService backupService)`:
       - Support two content types:
         a. `multipart/form-data`: Use shelf_multipart to extract file part, stream to backupService.storeBackup()
         b. `application/octet-stream`: Pass request.read() directly to backupService.storeBackup()
       - On success: return 200 JSON `{"filename": "...", "dbVersion": N}`
       - On validation failure (thrown by service): return 400 JSON `{"error": "..."}`
       - On no file: return 400 JSON `{"error": "No file uploaded"}`

    2. `Response listBackupsHandler(Request request, BackupService backupService)`:
       - Call backupService.listBackups()
       - Return 200 JSON array: `[{"filename": "...", "date": "YYYY-MM-DD", "sizeBytes": N, "dbVersion": N, "isValid": true}, ...]`

    3. `Response downloadBackupHandler(Request request, String filename, BackupService backupService)`:
       - Call backupService.getBackup(filename)
       - If null: return 404 JSON `{"error": "Backup not found"}`
       - Return file contents with Content-Type: application/octet-stream and Content-Disposition: attachment

    4. `Response deleteBackupHandler(Request request, String filename, BackupService backupService)`:
       - Call backupService.deleteBackup(filename)
       - If false: return 404 JSON `{"error": "Backup not found"}`
       - Return 200 JSON `{"deleted": true}`

    **server/bin/server.dart** (modify existing):
    - Import backup_api and backup_service
    - Create `BackupService(config.dataDir)` instance
    - Add routes to router:
      - `router.post('/api/backup', (req) => uploadBackupHandler(req, backupService))`
      - `router.get('/api/backups', (req) => listBackupsHandler(req, backupService))`
      - `router.get('/api/backup/<filename>', (req, filename) => downloadBackupHandler(req, filename, backupService))`
      - `router.delete('/api/backup/<filename>', (req, filename) => deleteBackupHandler(req, filename, backupService))`

    **Error handling:** Wrap handler bodies in try-catch. On unexpected errors, return 500 JSON `{"error": "Internal server error"}` and print the error for logging. Do NOT expose internal error details to the client.
  </action>
  <verify>
    `rg "uploadBackupHandler|listBackupsHandler|downloadBackupHandler|deleteBackupHandler" server/lib/api/backup_api.dart` finds all 4 handlers. `rg "router\.(post|get|delete).*backup" server/bin/server.dart` confirms routes are wired.
  </verify>
  <done>
    All 4 backup endpoints are implemented and wired to the router. Upload validates SQLite integrity, list returns metadata, download streams file, delete removes file. Retention cleanup runs after each upload.
  </done>
</task>

</tasks>

<verification>
1. `server/lib/services/sqlite_validator.dart` validates SQLite files and extracts DB version
2. `server/lib/services/backup_service.dart` stores, lists, downloads, deletes, and auto-cleans backups
3. `server/lib/api/backup_api.dart` has 4 endpoint handlers with proper error handling
4. `server/bin/server.dart` has all backup routes registered in the router
5. Upload supports both multipart/form-data and application/octet-stream
6. Filename sanitization prevents path traversal attacks
7. Retention cleanup follows GFS policy matching the app's implementation
</verification>

<success_criteria>
- SQLite validator correctly runs PRAGMA quick_check and reads user_version
- Backup service stores files with date-based naming, lists with metadata, and cleans up via GFS retention
- All 4 backup API endpoints are wired and return proper JSON responses
- Invalid files are rejected with 400, missing files return 404
</success_criteria>

<output>
After completion, create `.planning/phases/10-server-foundation/10-02-SUMMARY.md`
</output>
