---
phase: 10-server-foundation
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - server/lib/api/manage_page.dart
  - server/bin/server.dart
  - server/Dockerfile
  - server/docker-compose.yml
  - server/.dockerignore
autonomous: false

must_haves:
  truths:
    - "GET /manage?key=xxx renders HTML page listing all backups with date, size, DB version, and integrity status"
    - "Management page shows total storage usage"
    - "Management page has download and delete action links for each backup"
    - "Docker image builds successfully with multi-stage build"
    - "docker-compose up starts the server with env var configuration"
    - "Backup data persists across container restarts via named volume"
  artifacts:
    - path: "server/lib/api/manage_page.dart"
      provides: "Server-rendered HTML management page"
      exports: ["managePageHandler"]
      min_lines: 40
    - path: "server/Dockerfile"
      provides: "Multi-stage Docker build with AOT compilation"
      contains: "dart compile exe"
    - path: "server/docker-compose.yml"
      provides: "Docker Compose service definition with env vars and volume"
      contains: "JACKED_API_KEY"
    - path: "server/.dockerignore"
      provides: "Docker build context exclusions"
  key_links:
    - from: "server/lib/api/manage_page.dart"
      to: "server/lib/services/backup_service.dart"
      via: "BackupService for listing backups and storage info"
      pattern: "backupService"
    - from: "server/bin/server.dart"
      to: "server/lib/api/manage_page.dart"
      via: "router.get('/manage')"
      pattern: "managePageHandler"
    - from: "server/docker-compose.yml"
      to: "server/Dockerfile"
      via: "build context"
      pattern: "build"
---

<objective>
Create the server-rendered HTML backup management page and Docker deployment files (Dockerfile, docker-compose.yml, .dockerignore). Wire the management page into the server router.

Purpose: The management page provides a user-friendly web interface for backup management (SERVER-07). Docker files enable self-hosted deployment (DEPLOY-01/02/03).
Output: Complete server with management page, ready for Docker deployment.
</objective>

<execution_context>
@/home/aquatic/.claude/get-shit-done/workflows/execute-plan.md
@/home/aquatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-server-foundation/10-CONTEXT.md
@.planning/phases/10-server-foundation/10-RESEARCH.md
@.planning/phases/10-server-foundation/10-01-SUMMARY.md
@.planning/phases/10-server-foundation/10-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create management page and wire to router</name>
  <files>
    server/lib/api/manage_page.dart
    server/bin/server.dart
  </files>
  <action>
    **server/lib/api/manage_page.dart:**
    - Function `Response managePageHandler(Request request, BackupService backupService, String apiKey)`:
      - Call `backupService.listBackups()` to get all backups
      - Call `backupService.totalStorageBytes()` for total storage
      - Generate server-rendered HTML page with:
        - Title: "JackedLog Backup Management"
        - Meta viewport for mobile responsiveness
        - Inline CSS (clean, minimal styling — dark-themed to match a fitness app aesthetic):
          - System font stack
          - Max-width container (~800px, centered)
          - Styled table with alternating row colors
          - Action buttons/links styled distinctly (download = blue, delete = red)
        - Header showing "JackedLog Backups" and total storage (formatted as KB/MB/GB)
        - Table with columns: Date, Size, DB Version, Status, Actions
        - Each backup row:
          - Date: formatted from filename (YYYY-MM-DD)
          - Size: human-readable (KB/MB)
          - DB Version: integer from validation
          - Status: "Passed" (green) or "Failed" (red) based on isValid
          - Actions: Download link (`/api/backup/<filename>` with Authorization header via fetch or direct link with key param), Delete button (fetch DELETE with confirmation prompt)
        - Delete uses JavaScript `fetch('/api/backup/<filename>', {method: 'DELETE', headers: {'Authorization': 'Bearer <key>'}})` with `confirm()` dialog, then reloads page
        - Download links: simple `<a href="/api/backup/<filename>?key=<apiKey>">` — BUT the auth middleware uses Bearer token for API routes, not query params. So either: add a special download route that accepts query param auth, OR use JavaScript fetch + blob download. **Choose the simpler approach:** modify the download link to use JavaScript fetch with Bearer token, create blob URL, and trigger download. This keeps auth consistent.
        - Alternative simpler approach: Since the manage page already authenticates via `?key=` query param, pass the key through to the download/delete JavaScript calls.
        - Empty state: Show "No backups yet" message when list is empty
      - Return Response.ok with content-type text/html

    **For download/delete JavaScript in the management page:**
    - Use the API key from the page's own URL query parameter
    - Download: `fetch('/api/backup/' + filename, {headers: {'Authorization': 'Bearer ' + apiKey}}).then(r => r.blob()).then(blob => { /* create download link */ })`
    - Delete: `fetch('/api/backup/' + filename, {method: 'DELETE', headers: {'Authorization': 'Bearer ' + apiKey}}).then(() => location.reload())`

    **server/bin/server.dart** (modify existing):
    - Import manage_page
    - Add route: `router.get('/manage', (req) => managePageHandler(req, backupService, config.apiKey))`
  </action>
  <verify>
    `rg "managePageHandler" server/lib/api/manage_page.dart` confirms the handler exists. `rg "manage" server/bin/server.dart` confirms route is wired. `rg "totalStorage" server/lib/api/manage_page.dart` confirms storage display.
  </verify>
  <done>
    Management page renders HTML table of all backups with date, size, DB version, integrity status, download/delete actions, and total storage usage. Auth uses API key from URL query parameter. Page is wired to router at /manage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker deployment files</name>
  <files>
    server/Dockerfile
    server/docker-compose.yml
    server/.dockerignore
  </files>
  <action>
    **server/Dockerfile:**
    Multi-stage build targeting <50MB final image:

    ```dockerfile
    # Stage 1: Build
    FROM dart:stable AS build
    WORKDIR /app
    COPY pubspec.* ./
    RUN dart pub get
    COPY . .
    RUN dart compile exe bin/server.dart -o bin/server

    # Stage 2: Runtime
    FROM scratch
    COPY --from=build /runtime/ /
    COPY --from=build /app/bin/server /app/bin/server

    EXPOSE 8080
    CMD ["/app/bin/server"]
    ```

    Notes:
    - Use `dart:stable` as build image (official Dart Docker image)
    - Copy pubspec first for Docker layer caching
    - AOT compile with `dart compile exe` for native binary
    - `FROM scratch` for minimal image — only the compiled binary and /runtime/ (glibc, ca-certificates)
    - Do NOT add VOLUME directive in Dockerfile (managed by docker-compose)
    - EXPOSE 8080 as documentation

    **server/docker-compose.yml:**
    ```yaml
    services:
      jackedlog-server:
        build: .
        ports:
          - "${PORT:-8080}:8080"
        environment:
          - JACKED_API_KEY=${JACKED_API_KEY}
          - PORT=8080
          - DATA_DIR=/data
        volumes:
          - backup_data:/data
        restart: unless-stopped

    volumes:
      backup_data:
    ```

    Notes:
    - No `version` key (deprecated in modern docker-compose)
    - Port mapping uses env var with 8080 default
    - JACKED_API_KEY passed from host environment (user sets via .env or shell)
    - Named volume `backup_data` maps to /data inside container (DEPLOY-03)
    - restart: unless-stopped for reliability

    **server/.dockerignore:**
    ```
    .dart_tool/
    .packages
    build/
    pubspec.lock
    *.md
    .git/
    ```
    - Exclude build artifacts and unnecessary files from Docker context
    - Include pubspec.lock in ignore since we want fresh `dart pub get` in the build
  </action>
  <verify>
    `rg "dart compile exe" server/Dockerfile` confirms AOT compilation. `rg "JACKED_API_KEY" server/docker-compose.yml` confirms env var config. `rg "backup_data" server/docker-compose.yml` confirms persistent volume.
  </verify>
  <done>
    Dockerfile uses multi-stage build (dart:stable -> scratch) with AOT compilation. docker-compose.yml defines service with env var config and persistent named volume. .dockerignore excludes build artifacts.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete JackedLog server with backup API, management page, and Docker deployment files. The server receives/validates/stores SQLite backups, provides health check, renders HTML management page, and auto-cleans old backups via GFS retention policy.</what-built>
  <how-to-verify>
    1. Review server project structure: `ls -R server/`
    2. Check that all expected files exist:
       - server/pubspec.yaml, server/bin/server.dart
       - server/lib/config.dart, server/lib/middleware/auth.dart, server/lib/middleware/cors.dart
       - server/lib/api/health_api.dart, server/lib/api/backup_api.dart, server/lib/api/manage_page.dart
       - server/lib/services/sqlite_validator.dart, server/lib/services/backup_service.dart
       - server/Dockerfile, server/docker-compose.yml, server/.dockerignore
    3. Test locally: `cd server && dart pub get && JACKED_API_KEY=test dart run bin/server.dart`
    4. Test health: `curl http://localhost:8080/api/health`
    5. Test auth rejection: `curl http://localhost:8080/api/backups` (should get 401)
    6. Test auth success: `curl -H "Authorization: Bearer test" http://localhost:8080/api/backups`
    7. Test upload: `curl -X POST -H "Authorization: Bearer test" -H "Content-Type: application/octet-stream" --data-binary @<any-sqlite-file> http://localhost:8080/api/backup`
    8. Test manage page: Open `http://localhost:8080/manage?key=test` in browser
    9. Optionally test Docker: `cd server && docker compose up --build`
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Management page renders HTML with backup list, storage total, and download/delete actions
2. Dockerfile produces multi-stage build with AOT compilation targeting <50MB
3. docker-compose.yml configures JACKED_API_KEY, PORT, DATA_DIR via environment
4. Named volume `backup_data` persists data across container restarts
5. All server routes are complete: health, backup CRUD, and management page
</verification>

<success_criteria>
- Management page at /manage?key=xxx shows all backups with metadata and actions
- Total storage usage displayed on management page
- Docker image builds successfully with multi-stage build
- docker-compose up starts server with correct env var mapping
- Named volume ensures backup persistence across restarts
- Server is fully functional end-to-end: upload, list, download, delete, manage, health check
</success_criteria>

<output>
After completion, create `.planning/phases/10-server-foundation/10-03-SUMMARY.md`
</output>
