---
phase: 12-dashboard-query-layer
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - server/lib/services/dashboard_service.dart
autonomous: true

must_haves:
  truths:
    - "Exercise records return 1RM, best weight, and best volume for a given exercise name"
    - "Rep records return best weight at each rep count 1 through 15"
    - "Exercise search filters by name substring and optional category"
    - "Categories list returns all distinct non-null categories from gym_sets"
  artifacts:
    - path: "server/lib/services/dashboard_service.dart"
      provides: "Exercise records, rep records, search, and category filter methods"
      contains: "getExerciseRecords"
  key_links:
    - from: "server/lib/services/dashboard_service.dart"
      to: "gym_sets table"
      via: "SQL queries matching app patterns from gym_sets.dart"
      pattern: "FROM gym_sets.*WHERE.*hidden = 0"
---

<objective>
Add exercise-focused query methods to DashboardService: personal records (DASH-06), rep records table (DASH-07), and exercise search with category filter (DASH-10).

Purpose: Completes the query layer with exercise analytics. These methods provide the data for exercise detail pages and exercise browsing in the Phase 13 frontend.
Output: Extended `server/lib/services/dashboard_service.dart` with getExerciseRecords(), getRepRecords(), searchExercises(), and getCategories() methods.
</objective>

<execution_context>
@/home/aquatic/.claude/get-shit-done/workflows/execute-plan.md
@/home/aquatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-dashboard-query-layer/12-RESEARCH.md
@.planning/phases/12-dashboard-query-layer/12-01-SUMMARY.md
@server/lib/services/dashboard_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add exercise records and rep records methods</name>
  <files>server/lib/services/dashboard_service.dart</files>
  <action>
Add two public methods to the existing DashboardService class:

**getExerciseRecords(String exerciseName) method:**
Returns a Map with keys: `exerciseName`, `bestWeight`, `best1RM`, `bestVolume`, `hasRecords`.

If `_db == null`, return map with exerciseName set and all values null, `hasRecords: false`.

Main query (3 PRs in one query):
```sql
SELECT
  MAX(weight) as best_weight,
  MAX(CASE WHEN weight >= 0 THEN weight / (1.0278 - 0.0278 * reps)
      ELSE weight * (1.0278 - 0.0278 * reps) END) as best_1rm,
  MAX(weight * reps) as best_volume
FROM gym_sets WHERE name = ? AND hidden = 0 AND reps > 0
```
Parameter: `[exerciseName]`

**IMPORTANT:** The 1RM Brzycki formula handles both positive and negative weights (negative = assisted exercises). Add `AND reps > 0` to avoid division issues with 0 reps. Also add `AND weight != 0` to the 1RM CASE to avoid meaningless 1RM for bodyweight exercises — actually, keep it simple and match the app. The app's query does NOT filter `weight != 0`. Just use the exact SQL from the research doc, only adding `AND reps > 0` safety.

Map result: If all values are null (no matching sets), return `hasRecords: false`. Otherwise return the three values as doubles.

Return: `{ 'exerciseName': exerciseName, 'bestWeight': ..., 'best1RM': ..., 'bestVolume': ..., 'hasRecords': true/false }`

**getRepRecords(String exerciseName) method:**
Returns a Map with keys: `exerciseName`, `records` (List of Maps).

If `_db == null`, return `{ 'exerciseName': exerciseName, 'records': [] }`.

Query:
```sql
SELECT CAST(reps AS INTEGER) as rep_count,
  MAX(weight) as max_weight, created, unit, workout_id
FROM gym_sets
WHERE name = ? AND hidden = 0
  AND reps BETWEEN 1 AND 15
  AND reps = CAST(reps AS INTEGER)
GROUP BY CAST(reps AS INTEGER)
ORDER BY rep_count ASC
```
Parameter: `[exerciseName]`

Map each row to: `{ 'repCount': row['rep_count'], 'maxWeight': row['max_weight'], 'created': row['created'], 'unit': row['unit'], 'workoutId': row['workout_id'] }`

Return: `{ 'exerciseName': exerciseName, 'records': [list of maps] }`
  </action>
  <verify>
Run `dart analyze server/` to check for compilation errors. Verify DashboardService has getExerciseRecords() and getRepRecords() methods.
  </verify>
  <done>Exercise records return best weight, 1RM (Brzycki), and best volume per exercise. Rep records return best weight at each integer rep count 1-15. Both use hidden=0 filter and handle empty results.</done>
</task>

<task type="auto">
  <name>Task 2: Add exercise search and category filter methods</name>
  <files>server/lib/services/dashboard_service.dart</files>
  <action>
Add two public methods to the existing DashboardService class:

**getCategories() method:**
Returns a `List<String>` of distinct category names.

If `_db == null`, return empty list.

Query:
```sql
SELECT DISTINCT category FROM gym_sets
WHERE category IS NOT NULL AND hidden = 0
ORDER BY category
```

Map each row to the category string value.

**searchExercises({String search = '', String? category}) method:**
Returns a Map with keys: `exercises` (List of Maps), `totalCount` (int).

If `_db == null`, return `{ 'exercises': [], 'totalCount': 0 }`.

Build the query dynamically based on optional category filter:
```sql
SELECT name, category, MAX(created) as last_used,
  COUNT(*) as set_count, COUNT(DISTINCT workout_id) as workout_count
FROM gym_sets
WHERE hidden = 0
  AND name LIKE ?
  ${category != null ? 'AND category = ?' : ''}
GROUP BY name
ORDER BY workout_count DESC
```
Parameters: `['%$search%']` + `[category]` if category is not null.

**Important:** Sanitize the search string for SQL LIKE — the `%` wrapping is intentional for substring matching. The sqlite3 package handles parameter binding safely (no SQL injection risk with bound parameters).

Map each row to: `{ 'name': row['name'], 'category': row['category'], 'lastUsed': row['last_used'], 'setCount': row['set_count'], 'workoutCount': row['workout_count'] }`

Return: `{ 'exercises': [list of maps], 'totalCount': exercises.length }`
  </action>
  <verify>
Run `dart analyze server/` to check for compilation errors. Verify DashboardService has getCategories() and searchExercises() methods.
  </verify>
  <done>getCategories() returns distinct category names. searchExercises() filters by name substring and optional category, ordered by workout count. Both handle empty/null db gracefully.</done>
</task>

</tasks>

<verification>
1. `dart analyze server/` passes with no errors on dashboard_service.dart
2. DashboardService now has ALL required methods: open, close, getOverviewStats, getWorkoutHistory, getWorkoutDetail, getExerciseRecords, getRepRecords, getCategories, searchExercises
3. Brzycki 1RM formula: `weight / (1.0278 - 0.0278 * reps)` for positive weight, `weight * (1.0278 - 0.0278 * reps)` for negative weight
4. Rep records filter: `reps BETWEEN 1 AND 15 AND reps = CAST(reps AS INTEGER)` (integer reps only)
5. Exercise search uses LIKE with `%` wrapping for substring match
6. All gym_sets queries include `hidden = 0` filter
</verification>

<success_criteria>
- getExerciseRecords() returns 3 PRs (1RM, best weight, best volume) per exercise
- getRepRecords() returns best weight at each rep count 1-15
- getCategories() returns distinct non-null categories
- searchExercises() filters by name and optional category, returns exercises ordered by usage
- All queries match app SQL patterns from research doc
- `dart analyze server/` passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-dashboard-query-layer/12-02-SUMMARY.md`
</output>
