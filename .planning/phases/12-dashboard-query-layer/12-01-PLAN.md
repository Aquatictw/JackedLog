---
phase: 12-dashboard-query-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/lib/services/dashboard_service.dart
autonomous: true

must_haves:
  truths:
    - "DashboardService opens latest backup file in read-only mode and validates schema >= 48"
    - "Overview stats return correct workout count, total volume, current streak, and training time"
    - "Workout history returns paginated list (20 per page) ordered by start_time DESC"
    - "Workout detail returns all non-hidden sets for a workout ordered by sequence"
  artifacts:
    - path: "server/lib/services/dashboard_service.dart"
      provides: "DashboardService class with lifecycle management and core query methods"
      contains: "class DashboardService"
  key_links:
    - from: "server/lib/services/dashboard_service.dart"
      to: "sqlite3 package"
      via: "sqlite3.open with OpenMode.readOnly"
      pattern: "sqlite3\\.open.*readOnly"
---

<objective>
Create the DashboardService class with database lifecycle management (open/close/caching), overview stats queries (DASH-01), and workout history/detail queries (DASH-08, DASH-09).

Purpose: Establishes the query layer foundation that all dashboard data flows through. Opens backup SQLite files read-only and translates app SQL patterns into raw sqlite3 queries.
Output: `server/lib/services/dashboard_service.dart` with open/close lifecycle, overview stats, streak, training time, workout history, and workout detail methods.
</objective>

<execution_context>
@/home/aquatic/.claude/get-shit-done/workflows/execute-plan.md
@/home/aquatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-dashboard-query-layer/12-RESEARCH.md
@server/lib/services/sqlite_validator.dart
@server/lib/services/backup_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DashboardService with lifecycle and overview stats</name>
  <files>server/lib/services/dashboard_service.dart</files>
  <action>
Create `server/lib/services/dashboard_service.dart` with a `DashboardService` class.

**Class structure:**
- Constructor takes `String dataDir` (same data directory as BackupService)
- Private fields: `Database? _db`, `String? _currentFile`
- `bool get isOpen => _db != null`
- `String? get currentFile => _currentFile`

**open({String? filename}) method:**
- Close any existing handle first (call close())
- If no filename provided, find latest backup: list .db files in dataDir matching `jackedlog_backup_*.db` pattern, sort by name descending, take first
- If no backup found, return false
- Open with `sqlite3.open(filePath, mode: OpenMode.readOnly)`
- Read version: `PRAGMA user_version` — if version < 48, close and return false
- Store handle and filename, return true

**close() method:**
- Call `_db?.dispose()` to close handle (sqlite3 package uses dispose(), not close())
- Set `_db = null`, `_currentFile = null`

**IMPORTANT: Check the sqlite3 package API.** The `Database` class from `package:sqlite3/sqlite3.dart` uses `.dispose()` to close, NOT `.close()`. Verify this in the actual package before writing code. If `.close()` is the correct method, use that. Read the sqlite_validator.dart file — it uses `db.close()`, so follow that pattern.

**periodToEpoch(String? period) helper (private):**
```dart
int _periodToEpoch(String? period) {
  if (period == null || period == 'all') return 0;
  final now = DateTime.now();
  DateTime start;
  switch (period) {
    case 'week':
      start = now.subtract(const Duration(days: 7));
    case 'month':
      start = DateTime(now.year, now.month - 1, now.day);
    case 'year':
      start = DateTime(now.year - 1, now.month, now.day);
    default:
      return 0;
  }
  return start.millisecondsSinceEpoch ~/ 1000;
}
```

**getOverviewStats({String? period}) method:**
Return a Map with keys: `workoutCount`, `totalVolume`, `currentStreak`, `totalTimeSeconds`, `hasData`.

If `_db == null`, return map with all zeros and `hasData: false`.

Four queries (all use `startEpochSeconds` from `_periodToEpoch(period)`):

1. Workout count:
```sql
SELECT COUNT(DISTINCT id) as workout_count FROM workouts WHERE start_time >= ?
```
Parameter: `[startEpochSeconds]`

2. Total volume:
```sql
SELECT COALESCE(SUM(weight * reps), 0) as total_volume FROM gym_sets WHERE created >= ? AND hidden = 0 AND cardio = 0
```
Parameter: `[startEpochSeconds]`

3. Training time:
```sql
SELECT COALESCE(SUM(end_time - start_time), 0) as total_seconds FROM workouts WHERE start_time >= ? AND end_time IS NOT NULL
```
Parameter: `[startEpochSeconds]`

4. Current streak — call `_calculateStreak()` (separate private method):
```dart
int _calculateStreak() {
  if (_db == null) return 0;
  int streak = 0;
  final now = DateTime.now();
  var checkDate = DateTime(now.year, now.month, now.day);
  while (true) {
    final dateStr = '${checkDate.year.toString().padLeft(4, '0')}-'
        '${checkDate.month.toString().padLeft(2, '0')}-'
        '${checkDate.day.toString().padLeft(2, '0')}';
    final result = _db!.select(
      "SELECT COUNT(*) as count FROM workouts WHERE DATE(start_time, 'unixepoch') = ?",
      [dateStr],
    );
    if ((result.first['count'] as int) > 0) {
      streak++;
      checkDate = checkDate.subtract(const Duration(days: 1));
    } else {
      break;
    }
  }
  return streak;
}
```

Return map: `{ 'workoutCount': workoutCount, 'totalVolume': totalVolume, 'currentStreak': streak, 'totalTimeSeconds': totalSeconds, 'hasData': true }`

Import only `package:sqlite3/sqlite3.dart` and `dart:io` (for Directory/File listing).
  </action>
  <verify>
Run `dart analyze server/` to check for compilation errors in the new file. Verify the file exists and contains the DashboardService class with open(), close(), getOverviewStats(), and _calculateStreak() methods.
  </verify>
  <done>DashboardService opens backup files read-only, validates schema version >= 48, caches the handle, and returns overview stats (workout count, total volume, current streak, training time) with period filtering.</done>
</task>

<task type="auto">
  <name>Task 2: Add workout history and detail query methods</name>
  <files>server/lib/services/dashboard_service.dart</files>
  <action>
Add two public methods to the existing DashboardService class:

**getWorkoutHistory({int page = 1, int pageSize = 20, int? startEpoch, int? endEpoch}) method:**
Returns a Map with keys: `workouts` (List of Maps), `totalCount` (int), `page` (int), `pageSize` (int).

If `_db == null`, return `{ 'workouts': [], 'totalCount': 0, 'page': page, 'pageSize': pageSize }`.

Build a WHERE clause supporting optional date range:
- Base: `WHERE 1=1`
- If startEpoch != null: `AND w.start_time >= ?`
- If endEpoch != null: `AND w.start_time <= ?`

Count query:
```sql
SELECT COUNT(DISTINCT w.id) as total FROM workouts w {whereClause}
```

Data query (using LEFT JOIN for efficiency):
```sql
SELECT w.id, w.start_time, w.end_time, w.name, w.notes,
  COUNT(DISTINCT gs.name) as exercise_count,
  COUNT(gs.id) as set_count,
  COALESCE(SUM(gs.weight * gs.reps), 0) as total_volume
FROM workouts w
LEFT JOIN gym_sets gs ON w.id = gs.workout_id AND gs.hidden = 0 AND gs.sequence >= 0
{whereClause}
GROUP BY w.id
ORDER BY w.start_time DESC
LIMIT ? OFFSET ?
```
Parameters: `[...whereParams, pageSize, (page - 1) * pageSize]`

Map each row to: `{ 'id': row['id'], 'startTime': row['start_time'], 'endTime': row['end_time'], 'name': row['name'], 'notes': row['notes'], 'exerciseCount': row['exercise_count'], 'setCount': row['set_count'], 'totalVolume': row['total_volume'] }`

**getWorkoutDetail(int workoutId) method:**
Returns a Map with keys: `workout` (Map or null), `sets` (List of Maps).

If `_db == null`, return `{ 'workout': null, 'sets': [] }`.

Workout query:
```sql
SELECT id, start_time, end_time, name, notes FROM workouts WHERE id = ?
```
Parameter: `[workoutId]`

If no workout found, return `{ 'workout': null, 'sets': [] }`.

Sets query:
```sql
SELECT id, name, reps, weight, unit, created, category, exercise_type, set_type, set_order, sequence
FROM gym_sets
WHERE workout_id = ? AND hidden = 0 AND sequence >= 0
ORDER BY sequence, COALESCE(set_order, created)
```
Parameter: `[workoutId]`

Map workout row and each set row to plain Maps with camelCase keys.

For the workout map: `{ 'id': ..., 'startTime': ..., 'endTime': ..., 'name': ..., 'notes': ... }`
For each set: `{ 'id': ..., 'name': ..., 'reps': ..., 'weight': ..., 'unit': ..., 'created': ..., 'category': ..., 'exerciseType': ..., 'setType': ..., 'setOrder': ..., 'sequence': ... }`
  </action>
  <verify>
Run `dart analyze server/` to check for compilation errors. Verify DashboardService now has getWorkoutHistory() and getWorkoutDetail() methods.
  </verify>
  <done>Workout history returns paginated results with exercise count, set count, volume per workout. Workout detail returns workout metadata and all ordered sets. Both handle null/empty db gracefully.</done>
</task>

</tasks>

<verification>
1. `dart analyze server/` passes with no errors on dashboard_service.dart
2. DashboardService class has: open(), close(), isOpen, getOverviewStats(), getWorkoutHistory(), getWorkoutDetail()
3. All SQL queries include `hidden = 0` filter on gym_sets
4. Epoch timestamps handled correctly (seconds, not milliseconds)
5. Database opened in OpenMode.readOnly — never writes to backup
6. Schema version validation rejects < 48
</verification>

<success_criteria>
- dashboard_service.dart exists with DashboardService class
- open() finds latest backup, opens read-only, validates schema >= 48
- close() disposes handle cleanly
- getOverviewStats() returns workout count, volume, streak, training time with period filtering
- getWorkoutHistory() returns paginated workout list with aggregated stats
- getWorkoutDetail() returns workout + ordered sets
- All queries match app SQL patterns from research doc
- `dart analyze server/` passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-dashboard-query-layer/12-01-SUMMARY.md`
</output>
