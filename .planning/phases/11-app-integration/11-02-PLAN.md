---
phase: 11-app-integration
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - lib/server/backup_push_service.dart
  - lib/backup/auto_backup_settings.dart
autonomous: true

must_haves:
  truths:
    - "User can push backup to server by tapping a button on the backup page"
    - "User sees indeterminate progress bar while upload is in progress"
    - "After successful push, status area shows 'Last pushed: just now' with checkmark"
    - "After failed push, status area shows red error message"
    - "Before any push, status area shows 'Never pushed'"
    - "Push status persists across app restarts via database"
  artifacts:
    - path: "lib/server/backup_push_service.dart"
      provides: "Service with pushBackup() and testConnection() methods"
      contains: "pushBackup, testConnection"
    - path: "lib/backup/auto_backup_settings.dart"
      provides: "Push to server button with progress and status display"
      contains: "Push to Server, lastPushTime, lastPushStatus"
  key_links:
    - from: "lib/backup/auto_backup_settings.dart"
      to: "lib/server/backup_push_service.dart"
      via: "BackupPushService.pushBackup() call on button tap"
      pattern: "BackupPushService\\.pushBackup"
    - from: "lib/server/backup_push_service.dart"
      to: "lib/database/database.dart"
      via: "SettingsCompanion write for lastPushTime and lastPushStatus"
      pattern: "SettingsCompanion.*lastPushTime|lastPushStatus"
    - from: "lib/server/backup_push_service.dart"
      to: "server/lib/api/backup_api.dart"
      via: "POST /api/backup with Bearer auth and octet-stream body"
      pattern: "api/backup"
---

<objective>
Create the backup push service and add push-to-server button with status display on the existing backup settings page.

Purpose: This is the core feature of Phase 11 — the ability to actually send backup data from the app to the server. Without this, the server settings page from Plan 01 would have no purpose.

Output: A `BackupPushService` class handling file upload, and UI additions to the existing backup settings card showing push button, progress indicator, and last push status.
</objective>

<execution_context>
@/home/aquatic/.claude/get-shit-done/workflows/execute-plan.md
@/home/aquatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-app-integration/11-01-SUMMARY.md

@lib/backup/auto_backup_settings.dart
@lib/backup/auto_backup_service.dart
@lib/database/settings.dart
@lib/settings/settings_state.dart
@lib/export_data.dart
@lib/main.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backup push service</name>
  <files>lib/server/backup_push_service.dart</files>
  <action>
  Create `lib/server/backup_push_service.dart` with a `BackupPushService` class containing static methods:

  **`static Future<void> pushBackup(String serverUrl, String apiKey) async`:**
  1. WAL checkpoint: `await db.customStatement('PRAGMA wal_checkpoint(TRUNCATE)');`
  2. Get database file path: `final dbFolder = await getApplicationDocumentsDirectory(); final file = File(p.join(dbFolder.path, 'jackedlog.sqlite'));`
  3. Read file bytes: `final bytes = await file.readAsBytes();`
  4. Create HTTP request using `dart:io` HttpClient:
     ```dart
     final client = HttpClient();
     client.connectionTimeout = const Duration(seconds: 30);
     try {
       final uri = Uri.parse('$serverUrl/api/backup');
       final request = await client.postUrl(uri);
       request.headers.set('Authorization', 'Bearer $apiKey');
       request.headers.set('Content-Type', 'application/octet-stream');
       request.headers.set('Content-Length', bytes.length.toString());
       request.add(bytes);
       final response = await request.close();
       final statusCode = response.statusCode;
       // Drain the response body
       await response.drain<void>();
       if (statusCode == 401 || statusCode == 403) {
         throw Exception('Authentication failed. Check your API key.');
       }
       if (statusCode != 200 && statusCode != 201) {
         throw Exception('Server returned status $statusCode');
       }
     } finally {
       client.close();
     }
     ```
  5. On success: update settings with timestamp and status:
     ```dart
     await db.settings.update().write(
       SettingsCompanion(
         lastPushTime: Value(DateTime.now()),
         lastPushStatus: const Value('success'),
       ),
     );
     ```
  6. On exception: update settings with failed status, then rethrow:
     ```dart
     await db.settings.update().write(
       const SettingsCompanion(
         lastPushStatus: Value('failed'),
       ),
     );
     rethrow;
     ```

  **Imports needed:**
  - `dart:io` (HttpClient, File)
  - `package:drift/drift.dart` (Value, SettingsCompanion)
  - `package:path_provider/path_provider.dart`
  - `package:path/path.dart` as p
  - `../database/database.dart`
  - `../main.dart` (for db)

  **Important:** Do NOT use the `http` package for the upload — use `dart:io` `HttpClient` directly so we have control over the raw byte stream. The `http` package is fine for the connection test in Plan 01 (simple GET requests), but for file upload `HttpClient` gives better control.
  </action>
  <verify>Grep for `pushBackup` in `lib/server/backup_push_service.dart`. Grep for `wal_checkpoint` in the file to confirm WAL checkpoint. Grep for `api/backup` to confirm correct endpoint. Grep for `lastPushTime` and `lastPushStatus` to confirm status updates.</verify>
  <done>BackupPushService exists with pushBackup() that reads the SQLite file, sends it as octet-stream to POST /api/backup with Bearer auth, and updates lastPushTime/lastPushStatus in the database on success or failure.</done>
</task>

<task type="auto">
  <name>Task 2: Add push button and status display to backup settings</name>
  <files>lib/backup/auto_backup_settings.dart</files>
  <action>
  Modify `lib/backup/auto_backup_settings.dart` to add a server push section. This section should appear AFTER the existing auto-backup card content, but is only visible when `serverUrl` is configured (non-null, non-empty).

  **Add new state variables:**
  ```dart
  bool _isPushing = false;
  ```

  **Add a new section at the end of the Column children (after the retention policy info container, inside the `if (settings.value.automaticBackups)` block is too restrictive — the push feature should work independently of auto-backup). Instead, add it at the END of the main Column's children list, OUTSIDE the `if (settings.value.automaticBackups)` conditional, so it's always visible when server is configured:**

  Add after line `],` that closes the `if (settings.value.automaticBackups)` block's children list, but still inside the main Column:

  ```dart
  // Server push section — visible when server URL is configured
  if (settings.value.serverUrl != null && settings.value.serverUrl!.isNotEmpty) ...[
    const SizedBox(height: 24),
    const Divider(),
    const SizedBox(height: 16),

    // Push to server header
    Row(
      children: [
        Icon(
          Icons.cloud_upload_rounded,
          color: colorScheme.tertiary,
          size: 24,
        ),
        const SizedBox(width: 12),
        Text(
          'Push to Server',
          style: Theme.of(context).textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: colorScheme.onSurface,
          ),
        ),
      ],
    ),

    const SizedBox(height: 16),

    // Push status display (always visible)
    _buildPushStatus(context, settings.value, colorScheme),

    const SizedBox(height: 16),

    // Progress bar (only during push)
    if (_isPushing)
      Padding(
        padding: const EdgeInsets.only(bottom: 16),
        child: LinearProgressIndicator(
          borderRadius: BorderRadius.circular(4),
        ),
      ),

    // Push button
    FilledButton.icon(
      onPressed: _isPushing ? null : _performPush,
      icon: _isPushing
          ? SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: colorScheme.onPrimary,
              ),
            )
          : const Icon(Icons.cloud_upload_rounded),
      label: Text(_isPushing ? 'Pushing...' : 'Push Backup'),
      style: FilledButton.styleFrom(
        minimumSize: const Size.fromHeight(48),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
    ),
  ],
  ```

  **Add `_buildPushStatus` method:**
  ```dart
  Widget _buildPushStatus(BuildContext context, Setting settings, ColorScheme colorScheme) {
    final lastPushTime = settings.lastPushTime;
    final lastPushStatus = settings.lastPushStatus;

    IconData icon;
    String statusText;
    Color color;

    if (lastPushTime == null) {
      icon = Icons.cloud_off_rounded;
      statusText = 'Never pushed';
      color = colorScheme.outline;
    } else if (lastPushStatus == 'failed') {
      icon = Icons.error_outline_rounded;
      statusText = 'Last push failed';
      color = colorScheme.error;
    } else {
      icon = Icons.check_circle_outline_rounded;
      statusText = 'Last pushed: ${timeago.format(lastPushTime)}';
      color = colorScheme.primary;
    }

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerHighest.withValues(alpha: 0.5),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: colorScheme.outlineVariant,
        ),
      ),
      child: Row(
        children: [
          Icon(icon, size: 20, color: color),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Server Backup',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  statusText,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: color,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),
          Icon(icon, size: 16, color: color),
        ],
      ),
    );
  }
  ```

  **Add `_performPush` method:**
  ```dart
  Future<void> _performPush() async {
    final settings = context.read<SettingsState>();
    final serverUrl = settings.value.serverUrl;
    final apiKey = settings.value.serverApiKey;

    if (serverUrl == null || serverUrl.isEmpty || apiKey == null || apiKey.isEmpty) {
      return;
    }

    setState(() {
      _isPushing = true;
    });

    try {
      await BackupPushService.pushBackup(serverUrl, apiKey);
      if (mounted) {
        await settings.init();
      }
    } catch (e) {
      if (mounted) {
        await settings.init();
      }
    } finally {
      if (mounted) {
        setState(() {
          _isPushing = false;
        });
      }
    }
  }
  ```

  **Add import at top of file:**
  ```dart
  import '../server/backup_push_service.dart';
  ```

  **Note:** The push section intentionally does NOT use toasts for success/failure feedback. Per the CONTEXT.md decision, it uses in-place status update near the button. The status display updates reactively through SettingsState because BackupPushService writes lastPushTime and lastPushStatus to the database, which triggers the stream subscription in SettingsState.

  **Note:** `timeago` is already imported in this file.
  </action>
  <verify>Grep for `Push to Server` in auto_backup_settings.dart. Grep for `_performPush` and `_buildPushStatus`. Grep for `BackupPushService` in auto_backup_settings.dart. Grep for `_isPushing` to confirm progress state. Grep for `Never pushed` to confirm initial state text.</verify>
  <done>Backup settings page shows "Push to Server" section when server URL is configured. Push button triggers upload with indeterminate progress bar. Status area shows "Never pushed" initially, "Last pushed: {timeago}" on success with checkmark, or "Last push failed" in red on failure. All status persists via database.</done>
</task>

</tasks>

<verification>
1. `lib/server/backup_push_service.dart` exists with `pushBackup` static method
2. `lib/backup/auto_backup_settings.dart` has push button, progress indicator, and status display
3. Push section only visible when `serverUrl` is configured
4. Status shows "Never pushed" when `lastPushTime` is null
5. Status shows "Last pushed: {timeago}" with green checkmark on success
6. Status shows "Last push failed" in red on failure
7. Indeterminate LinearProgressIndicator shows during push
8. Push service reads SQLite file, sends as octet-stream with Bearer auth
9. Push service updates lastPushTime and lastPushStatus in database
</verification>

<success_criteria>
- User can push backup from the backup settings page to configured server
- Indeterminate progress bar visible during upload
- Status display reactively updates from database (success shows timestamp, failure shows error)
- "Never pushed" shown before first push attempt
- Push service properly checkpoints WAL, reads file, sends as octet-stream, handles errors
- Status persists across app restarts
</success_criteria>

<output>
After completion, create `.planning/phases/11-app-integration/11-02-SUMMARY.md`
</output>
