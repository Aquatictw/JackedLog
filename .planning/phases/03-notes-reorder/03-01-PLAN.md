---
phase: 03-notes-reorder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/database/notes.dart
  - lib/database/database.dart
  - lib/notes/notes_page.dart
  - lib/notes/note_editor_page.dart
autonomous: true

must_haves:
  truths:
    - "User can long-press and drag notes to reorder them"
    - "Note order persists after app restart"
    - "Reorder disabled when search query is active"
    - "New notes appear at top of list"
  artifacts:
    - path: "lib/database/notes.dart"
      provides: "Sequence column definition"
      contains: "sequence"
    - path: "lib/database/database.dart"
      provides: "v62 migration with sequence backfill"
      contains: "schemaVersion => 62"
    - path: "lib/notes/notes_page.dart"
      provides: "ReorderableListView with long-press drag"
      contains: "ReorderableListView.builder"
  key_links:
    - from: "lib/notes/notes_page.dart"
      to: "db.notes"
      via: "batch update on reorder"
      pattern: "db.batch"
    - from: "lib/notes/note_editor_page.dart"
      to: "db.notes"
      via: "sequence assignment on create"
      pattern: "sequence.*Value"
---

<objective>
Implement drag-drop reordering for notes with database-backed persistence.

Purpose: Users can organize notes in their preferred order, with order preserved across app restarts.
Output: Notes table has sequence column, notes_page uses ReorderableListView, new notes get highest sequence.
</objective>

<execution_context>
@/home/aquatic/.claude/get-shit-done/workflows/execute-plan.md
@/home/aquatic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-notes-reorder/03-CONTEXT.md
@.planning/phases/03-notes-reorder/03-RESEARCH.md

Key patterns from codebase:
- lib/plan/start_list.dart: ReorderableListView with db.batch for sequence updates
- lib/plan/start_plan_page.dart: proxyDecorator pattern for visual lift effect
- lib/database/database.dart: v45->46 migration for plan_exercises sequence column (same pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sequence column to notes table and migration</name>
  <files>lib/database/notes.dart, lib/database/database.dart</files>
  <action>
    1. In lib/database/notes.dart, add sequence column:
       ```dart
       IntColumn get sequence => integer().nullable()();
       ```

    2. In lib/database/database.dart:
       - Change schemaVersion from 61 to 62
       - Add migration block for v61->v62 after the from57To61 block:
         ```dart
         // from61To62: Add sequence to notes
         // Runs when migrating FROM a version <=61 TO a version >=62
         if (from < 62 && to >= 62) {
           // Add sequence column
           await m.database.customStatement(
             'ALTER TABLE notes ADD COLUMN sequence INTEGER',
           ).catchError((e) {});

           // Backfill: assign sequence based on updated timestamp (most recent = highest)
           await m.database.customStatement('''
             UPDATE notes
             SET sequence = (
               SELECT COUNT(*)
               FROM notes n2
               WHERE n2.updated > notes.updated
             )
           ''');
         }
         ```

    3. Run `dart run build_runner build` to regenerate database.g.dart
  </action>
  <verify>
    - lib/database/notes.dart contains `sequence` column
    - lib/database/database.dart has schemaVersion => 62
    - Migration block exists for v61->v62
    - No syntax errors in migration SQL
  </verify>
  <done>
    Notes table has sequence column, v62 migration adds and backfills sequence for existing notes
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert notes page to ReorderableListView</name>
  <files>lib/notes/notes_page.dart</files>
  <action>
    1. Add state variable to track notes locally for responsive reordering:
       ```dart
       List<Note>? _localNotes;
       ```

    2. Replace GridView.builder with conditional logic:
       - When _searchQuery.isNotEmpty: use regular ListView.builder (no reorder during search)
       - When _searchQuery.isEmpty: use ReorderableListView.builder with long-press drag

    3. Update StreamBuilder to order by sequence desc (highest = top):
       ```dart
       stream: (db.notes.select()
         ..orderBy([
           (n) => OrderingTerm(expression: n.sequence, mode: OrderingMode.desc),
         ]))
         .watch(),
       ```

    4. Sync stream data to _localNotes when it changes (in builder):
       ```dart
       if (_localNotes == null || _searchQuery.isNotEmpty) {
         _localNotes = List.from(notes);
       }
       ```

    5. Implement onReorder callback:
       ```dart
       onReorder: (oldIndex, newIndex) async {
         if (oldIndex < newIndex) newIndex--;

         setState(() {
           final item = _localNotes!.removeAt(oldIndex);
           _localNotes!.insert(newIndex, item);
         });

         // Batch update sequences (highest index = highest sequence = top of list)
         await db.batch((batch) {
           for (var i = 0; i < _localNotes!.length; i++) {
             batch.update(
               db.notes,
               NotesCompanion(sequence: Value(_localNotes!.length - 1 - i)),
               where: (n) => n.id.equals(_localNotes![i].id),
             );
           }
         });
       },
       ```

    6. Add proxyDecorator for visual lift effect:
       ```dart
       proxyDecorator: (child, index, animation) {
         return Material(
           elevation: 8,
           shadowColor: colorScheme.shadow.withValues(alpha: 0.3),
           borderRadius: BorderRadius.circular(16),
           child: child,
         );
       },
       ```

    7. Update itemBuilder to use _localNotes and add ValueKey:
       ```dart
       itemBuilder: (context, index) {
         final note = _localNotes![index];
         final color = _getColorFromValue(note.color);
         return _NoteCard(
           key: ValueKey(note.id),
           note: note,
           color: color,
           onTap: () => _editNote(note),
           onDelete: () => _deleteNote(note),
         );
       },
       ```

    8. Adjust card layout for single-column list view:
       - Remove GridView and its SliverGridDelegate
       - Use ListView padding with horizontal margins
       - Update _NoteCard to use full width with appropriate height
       - Keep card styling (rounded corners, elevation, color)

    9. Reset _localNotes when search query changes:
       In onChanged of search TextField:
       ```dart
       setState(() {
         _searchQuery = value.toLowerCase();
         _localNotes = null; // Force resync with stream
       });
       ```
  </action>
  <verify>
    - ReorderableListView.builder used when not searching
    - ListView.builder used when searching (reorder disabled)
    - proxyDecorator provides elevation during drag
    - ValueKey on each note card
    - onReorder updates local state then batch updates database
    - Notes ordered by sequence descending
  </verify>
  <done>
    Notes page displays as reorderable list, long-press drag works, visual lift on drag, order persists to database
  </done>
</task>

<task type="auto">
  <name>Task 3: Assign sequence to new notes</name>
  <files>lib/notes/note_editor_page.dart</files>
  <action>
    1. Update _saveNote() method for new note creation:
       ```dart
       if (widget.note == null) {
         // Get max sequence to put new note at top
         final maxSeqResult = await (db.notes.selectOnly()
           ..addColumns([db.notes.sequence.max()]))
           .map((row) => row.read(db.notes.sequence.max()))
           .getSingleOrNull();

         final newSequence = (maxSeqResult ?? -1) + 1;

         // Create new note with sequence
         final companion = NotesCompanion.insert(
           title: title.isEmpty ? 'Untitled' : title,
           content: content,
           created: now,
           updated: now,
           color: Value(colorValue),
           sequence: Value(newSequence),
         );
         // ... rest of insert logic
       }
       ```

    2. Ensure the import for drift Value is present (should already be there)
  </action>
  <verify>
    - New note creation includes sequence: Value(newSequence)
    - newSequence is MAX(sequence) + 1
    - Existing update logic unchanged (sequence not modified on edit)
  </verify>
  <done>
    New notes created with highest sequence value, appearing at top of list
  </done>
</task>

</tasks>

<verification>
1. Database migration:
   - schemaVersion is 62
   - Migration SQL is valid (ALTER TABLE, UPDATE with subquery)
   - Backfill assigns sequence based on updated timestamp

2. UI functionality:
   - Notes display in list format (not grid)
   - Long-press on note initiates drag
   - Dragging note shows elevated shadow
   - Dropping note persists new order
   - Search disables reorder (switches to regular ListView)

3. Data persistence:
   - Close and reopen app: note order preserved
   - Create new note: appears at top
   - Edit existing note: position unchanged
</verification>

<success_criteria>
- User can long-press and drag notes to reorder
- Order persists after app restart (sequence stored in database)
- New notes appear at top of list
- Reorder disabled during search
- Visual lift effect during drag
- Database version is 62
</success_criteria>

<output>
After completion, create `.planning/phases/03-notes-reorder/03-01-SUMMARY.md`
</output>
